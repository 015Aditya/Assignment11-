{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "4efd321e-cfbe-4abe-9331-8370d185535a",
   "metadata": {},
   "source": [
    "Questions1 -> what is multithreading in python? hy is it used? Name the module used to handle threads in python\n",
    "\n",
    "Solution  ->  Multithreading in Python programming is a well-known technique in which multiple threads in a process share their data space with the main thread which makes information                 sharing and communication within threads easy and efficient. Threads are lighter than processes. Multi threads may execute individually while sharing their process                       resources. The purpose of multithreading is to run multiple tasks and function cells at the same time.\n",
    "Multithreading allows you to break down an application into multiple sub-tasks and run these tasks simultaneously. If you use multithreading properly, your application speed, performance, and rendering can all be improved.\n",
    "Python supports constructs for both multiprocessing as well as multithreading. In this tutorial, you will primarily be focusing on implementing multithreaded applications with python. There are two main modules which can be used to handle threads in Python:\n",
    "\n",
    "(1)The thread module\n",
    "(2)The threading module\n",
    "\n",
    "The two modules that you will learn about in this tutorial are the thread module and the threading module.\n",
    "However, the thread module has long been deprecated. Starting with Python 3, it has been designated as obsolete and is only accessible as __thread for backward compatibility.\n",
    "You should use the higher-level threading module for applications which you intend to deploy. The thread module has only been covered here for educational purposes.\n",
    "\n",
    "Syntex ->\n",
    "thread.start_new_thread(function_name, arguments)\n",
    "\n",
    "\n",
    "\n",
    "Questions2 -> Why threading module used? rite the use of the following functions -> activeCount()\n",
    "                                                                                    currentThread()\n",
    "                                                                                    enumerate()\n",
    "                                                                                    \n",
    "Solution -> The newer threading module included with Python 2.4 provides much more powerful, high-level support for threads than the thread module discussed in the previous section.                  To implement a new thread using the threading module, you have to do the following −\n",
    "            Define a new subclass of the Thread class.\n",
    "            Override the __init__(self [,args]) method to add additional arguments.\n",
    "            Then, override the run(self [,args]) method to implement what the thread should do when started.\n",
    "            Once you have created the new Thread subclass, you can create an instance of it and then start a new thread by invoking the start(), which in turn calls run() method.         \n",
    "            \n",
    "threading.activeCount() − Returns the number of thread objects that are active.\n",
    "threading.currentThread() − Returns the number of thread objects in the caller's thread control.\n",
    "threading.enumerate() − Returns a list of all thread objects that are currently active.\n",
    "\n",
    "\n",
    "\n",
    "Question3 -> Explain the following functions->  run()\n",
    "                                                start()\n",
    "                                                join()\n",
    "                                               isAlive()\n",
    "                                               \n",
    "Solution -> (1)run() − The run() method is the entry point for a thread.\n",
    "\n",
    "(2)start() − The start() method starts a thread by calling the run method.\n",
    "\n",
    "(3)join([time]) − The join() waits for threads to terminate.\n",
    "\n",
    "(4)isAlive() − The isAlive() method checks whether a thread is still executing.     \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "Question5 -> State advantages and disadvantages of multithreading?\n",
    "\n",
    "Solution -> Multithreaded and multicontexted applications offer the following advantages:\n",
    "\n",
    "-Improved performance and concurrency\n",
    " For certain applications, performance and concurrency can be improved by using multithreading and multicontexting together. In other applications, performance can be unaffected or even   degraded by using multithreading and multicontexting together. How performance is affected depends on your application.\n",
    "\n",
    "-Simplified coding of remote procedure calls and conversations\n",
    " In some applications it is easier to code different remote procedure calls and conversations in separate threads than to manage them from the same thread.\n",
    "\n",
    "-Simultaneous access to multiple applications\n",
    " Your BEA Tuxedo clients can be connected to more than one application at a time.\n",
    "\n",
    "-Reduced number of required servers\n",
    " Because one server can dispatch multiple service threads, the number of servers to start for your application is reduced. This capability for multiple dispatched threads is especially     useful for conversational servers, which otherwise must be dedicated to one client for the entire duration of a conversation.\n",
    " \n",
    " \n",
    " \n",
    " \n",
    "Question6 -> Explain deadlock and race condition?\n",
    "\n",
    "Solution -> Dead lock-\n",
    "            When two processes are waiting for each other directly or indirectly, it is called deadlock.\n",
    "            This usually occurs when two processes are waiting for shared resources acquired by others. For example, If thread T1 acquired resource R1 and it also needs resource R2 for               it to accomplish its task. But the resource R2 is acquired by thread T2 which is waiting for resource R1(which is acquired by T1).. Neither of them will be able to accomplish             its task, as they keep waiting for the other resources they need.\n",
    "\n",
    "Race condition-\n",
    "When two processes are competing with each other causing data corruption.\n",
    "For example, if two processes/threads are trying to execute the following conditions simultaneously, they cause data corruption:\n",
    "\n",
    "Thread 1:\n",
    "total = num1 + num2\n",
    "\n",
    "Thread 2:\n",
    "total = num1 - num2\n",
    "\n",
    "It is very common for the race conditions to go unnoticed during testing even after multiple tests and code reviews. But in production, there would be a lot of processes and threads working parallelly and compete for the same resources, and this problem would occur.\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
